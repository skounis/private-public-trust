# Breakdown of the communication between Alice and Bob

## Basic encrypted communication
That's a classic scenario in secure communication! Here's a breakdown of the process:

1. **Alice Encrypts and Signs the Message:**
   - Alice writes her message.
   - She then encrypts the message using Bob's public key. This ensures that only Bob can decrypt and read the message because only Bob's private key can decrypt messages encrypted with his public key.
   - Additionally, Alice signs the encrypted message using her private key. This provides authentication and ensures that Bob can verify that the message indeed comes from Alice.

2. **Bob Receives the Message:**
   - Bob receives the encrypted and signed message from Alice.
   - He first verifies the signature on the message using Alice's public key. If the signature is valid, Bob knows that the message was indeed sent by Alice and hasn't been tampered with.
   - Next, Bob decrypts the message using his own private key. Since the message was encrypted with his public key, only his private key can decrypt it.
   - Finally, Bob can read the decrypted message.

This process ensures confidentiality (only Bob can read the message), authenticity (Bob knows the message is from Alice), and integrity (Bob knows the message hasn't been altered). It's a fundamental concept in secure communication using public-key cryptography.


## Introduce Trust
Ensuring the authenticity of public keys is crucial for secure communication. Let's incorporate the role of the Bank as a trust provider into the flow:

1. **Alice Obtains a Certificate from the Bank:**
   - Before Alice sends her encrypted and signed message to Bob, she obtains a certificate from the Bank.
   - This certificate contains Alice's public key and is signed by the Bank using the Bank's private key.
   - The certificate serves as a trusted assertion by the Bank that the public key it contains indeed belongs to Alice.

2. **Alice Encrypts and Signs the Message with Certificate Validation:**
   - Alice writes her message.
   - She then encrypts the message using Bob's public key.
   - Additionally, Alice signs the encrypted message using her private key.
   - Alice includes her certificate in the message.

3. **Bob Receives the Message and Validates Alice's Certificate:**
   - Bob receives the encrypted and signed message along with Alice's certificate.
   - Bob first verifies the signature on the message using Alice's public key extracted from the certificate. If the signature is valid, Bob knows that the message was indeed sent by Alice and hasn't been tampered with.
   - Next, Bob validates Alice's certificate. He verifies the signature on the certificate using the Bank's public key (which Bob trusts). If the signature is valid, Bob knows that the certificate is authentic and hasn't been tampered with.
   - Bob then extracts Alice's public key from the validated certificate and uses it to decrypt the message.
   - Finally, Bob can read the decrypted message.

By involving the Bank as a trusted third party, Bob can trust that the public key he obtains from Alice's certificate indeed belongs to Alice, thus enhancing the security of the communication channel.

### Keys and Certificates involved
Here's a breakdown of the private/public key pairs and related certificates needed for the scenario:

1. **Alice's Key Pair:**
   - **Private Key (Alice's Private Key):** This is known only to Alice and is used for signing messages.
   - **Public Key (Alice's Public Key):** This key is freely available and is used by others to verify signatures made by Alice.

2. **Bob's Key Pair:**
   - **Private Key (Bob's Private Key):** This is known only to Bob and is used for decrypting messages encrypted with Bob's public key.
   - **Public Key (Bob's Public Key):** This key is freely available and is used by others, like Alice, to encrypt messages intended for Bob.

3. **Bank's Key Pair:**
   - **Private Key (Bank's Private Key):** This key is known only to the Bank and is used for signing certificates.
   - **Public Key (Bank's Public Key):** This key is freely available and is used by others to verify signatures on certificates issued by the Bank.

4. **Certificate:**
   - **Alice's Certificate:** This certificate is issued by the Bank and contains:
     - Alice's public key.
     - Information about Alice (e.g., name, email).
     - Expiration date (if applicable).
     - Digital signature from the Bank using the Bank's private key to verify the authenticity of the certificate.

   - **Bank's Self-Signed Certificate:** This certificate is generated by the Bank and serves as its root certificate or certificate authority (CA) certificate. It contains:
      - Bank's public key.
      - Information about the Bank (e.g., name, organization).
      - Expiration date (if applicable).
      - It is self-signed, meaning the Bank signs the certificate using its private key.
      
      This certificate is used by the Bank to sign certificates issued to entities like Alice, thereby establishing trust in the certificates issued by the Bank.
      
      The Bank's self-signed certificate acts as the root of trust in the certificate chain. When Bob receives Alice's certificate signed by the Bank, he can verify the authenticity of the certificate by validating the Bank's self-signed certificate. If Bob trusts the Bank's self-signed certificate, he can trust the certificates issued by the Bank, including Alice's certificate.

With these components in place, Alice can securely communicate with Bob:
- Alice uses her private key to sign messages and encrypts them with Bob's public key.
- Alice includes her certificate, issued by the Bank, in the message to Bob.
- Bob validates Alice's certificate using the Bank's public key and extracts Alice's public key from the validated certificate to decrypt the message.


### Generate keys and certificates with OpenSSL
Here's a basic example of how you can use OpenSSL and the command line (bash) to generate private/public key pairs and a self-signed certificate:

1. **Generate Alice's Key Pair:**
```bash
openssl genpkey -algorithm RSA -out alice_private.key -aes256 -pass pass:
openssl rsa -pubout -in alice_private.key -out alice_public.pem
```

2. **Generate Bob's Key Pair:**
```bash
openssl genpkey -algorithm RSA -out bob_private.key -aes256 -pass pass:
openssl rsa -pubout -in bob_private.key -out bob_public.pem
```

3. **Generate Bank's Key Pair:**
```bash
openssl genpkey -algorithm RSA -out bank_private.key -aes256 -pass pass:
openssl rsa -pubout -in bank_private.key -out bank_public.pem
```

4. **Create the Bank's Self-Signed Certificate:**
```bash
openssl req -x509 -new -key bank_private.key -out bank_cert.crt -days 365
```

5. **Create Alice's Certificate Signing Request (CSR):**
```bash
openssl req -new -key alice_private.key -out alice.csr
```

6. **Create a configuration file for certificate signing:**
```bash
echo "subjectAltName=email:alice@example.com" > alice_cert_config.cnf
```

7. **Sign Alice's CSR with the Bank's private key to obtain the certificate:**
```bash
openssl x509 -req -days 365 -in alice.csr -CA bank_cert.crt -CAkey bank_private.key -CAcreateserial -out alice_cert.crt -extfile alice_cert_config.cnf
```

These commands generate the necessary private/public key pairs and certificates using OpenSSL and the command line in bash.

#### Puting all together
```bash 
# Generate Alice's Key Pair without passphrase
openssl genpkey -algorithm RSA -out alice_private.key -aes256 -pass pass:
openssl rsa -pubout -in alice_private.key -out alice_public.pem

# Generate Bob's Key Pair without passphrase
openssl genpkey -algorithm RSA -out bob_private.key -aes256 -pass pass:
openssl rsa -pubout -in bob_private.key -out bob_public.pem

# Generate Bank's Key Pair without passphrase
openssl genpkey -algorithm RSA -out bank_private.key -aes256 -pass pass:
openssl rsa -pubout -in bank_private.key -out bank_public.pem

# Create the Bank's Self-Signed Certificate
openssl req -x509 -new -key bank_private.key -out bank_cert.crt -days 365

# Create Alice's Certificate Signing Request (CSR)
openssl req -new -key alice_private.key -out alice.csr

# Create a configuration file for certificate signing
echo "subjectAltName=email:alice@example.com" > alice_cert_config.cnf

# Sign Alice's CSR with the Bank's private key to obtain the certificate
openssl x509 -req -days 365 -in alice.csr -CA bank_cert.crt -CAkey bank_private.key -CAcreateserial -out alice_cert.crt -extfile alice_cert_config.cnf
```

The `bank_cert.srl` file is a serial file generated by OpenSSL when signing certificates. It serves as a serial number database for tracking the issuance of certificates.

When a certificate is signed by a certificate authority (CA), OpenSSL assigns a unique serial number to each certificate it signs. This serial number is then recorded in the `bank_cert.srl` file, along with the issuer's name and the expiration date of the certificate.

The purpose of the `bank_cert.srl` file is to ensure that each certificate signed by the CA has a unique identifier, which helps prevent certificate reuse or duplication. Additionally, it helps maintain the integrity and security of the certificate issuance process by keeping track of which certificates have been issued and when.

While the `bank_cert.srl` file itself doesn't contain sensitive information, it is important for OpenSSL's internal management of certificate issuance.

### Alice encrypts and sings her message 

In addition to encrypting the message, Alice also needs to sign it using her private key to ensure authenticity. Here's how she can encrypt the message and sign it using OpenSSL:

```bash
# Encrypt the message using Bob's public key
openssl rsautl -encrypt -pubin -inkey bob_public.pem -in plaintext_message.txt -out encrypted_message.bin

# Sign the encrypted message using Alice's private key
openssl dgst -sha256 -sign alice_private.key -out encrypted_message.sha256 encrypted_message.bin
```

Replace `bob_public.pem` with the actual filename/path of Bob's public key file, `plaintext_message.txt` with the actual filename/path of the plaintext message file containing "My secret message to Bob", and `alice_private.key` with the actual filename/path of Alice's private key file.

This series of commands will first encrypt the message using Bob's public key and output the encrypted message to a file named `encrypted_message.bin`. Then, it will sign the encrypted message using Alice's private key and output the signature to a file named `encrypted_message.sha256`.

After completing the encryption and signing process, Alice will have two files:

1. **encrypted_message.bin:** This file contains the encrypted message, which has been encrypted using Bob's public key. Only Bob, with his corresponding private key, will be able to decrypt and read the message.

2. **encrypted_message.sha256:** This file contains the digital signature of the encrypted message. It has been signed by Alice using her private key. Bob can use Alice's public key to verify the signature and ensure that the message indeed comes from Alice and hasn't been altered.

These two files together form the securely encrypted and signed message that Alice can send to Bob.


### Bob trusts and reads the message 
Let's revise the steps to include the Bank's certificate:

1. **Verify the Message Source:**
   - Bob receives the encrypted message and Alice's certificate from Alice.
   - Bob first needs to verify that the certificate provided by Alice is valid and issued by a trusted authority, in this case, the Bank.
   - Bob uses the Bank's public key, which he trusts, to verify the signature on Alice's certificate.

2. **Verify Alice's Identity:**
   - After verifying the certificate, Bob can extract Alice's public key from the validated certificate. This step ensures that Bob trusts that the public key indeed belongs to Alice, as it has been certified by the Bank.

3. **Verify the Signature:**
   - With Alice's public key in hand, Bob then verifies the digital signature attached to the encrypted message. This step ensures that the message hasn't been tampered with and that it was indeed signed by Alice.

4. **Decrypt the Message:**
   - Once Bob has verified Alice's identity and the signature, he can proceed to decrypt the message using his private key. Since the message was encrypted with Bob's public key, only Bob's private key can decrypt it.

By involving the Bank's certificate, Bob can trust that the public key provided by Alice indeed belongs to her, enhancing the security of the communication channel. 

Here's a code snippet for Bob to perform the steps you described using OpenSSL and the command line:

```bash
# Create folder for Bob's output
mkdir -p bobs

# Verify Alice's Identity
openssl dgst -sha256 -verify ./bobs/alice_public.pem -signature encrypted_message.sha256 encrypted_message.bin

# Trust Alice's certificate because he trusts the Bank
openssl verify -CAfile bank_cert.crt alice_cert.crt

# Extract Alice's public key from the certificate
openssl x509 -in alice_cert.crt -pubkey -noout > ./bobs/alice_public.pem

# Decrypt the Message
openssl rsautl -decrypt -inkey bob_private.key -in encrypted_message.bin -out ./bobs/decrypted_message.txt
```

Replace `alice_cert.crt` with the actual filename/path of Alice's certificate file, `bank_cert.crt` with the actual filename/path of the Bank's certificate file, `encrypted_message.sha256` with the actual filename/path of the signature file received from Alice, `encrypted_message.bin` with the actual filename/path of the encrypted message file received from Alice, and `bob_private.key` with the actual filename/path of Bob's private key file.

These commands perform the steps Bob needs to take to verify the message source, verify Alice's identity using the Bank's certificate, and decrypt the message. 

### Alice and Bob communication consolidated
Here's a consolidated script containing the code snippets for both Alice and Bob:

```bash
# Alice's Steps

# Encrypt the message using Bob's public key
openssl rsautl -encrypt -pubin -inkey bob_public.pem -in plaintext_message.txt -out encrypted_message.bin

# Sign the encrypted message using Alice's private key
openssl dgst -sha256 -sign alice_private.key -out encrypted_message.sha256 encrypted_message.bin

# Bob's Steps

# Create folder for Bob's output
mkdir -p bobs

# Verify Alice's Identity
openssl dgst -sha256 -verify ./bobs/alice_public.pem -signature encrypted_message.sha256 encrypted_message.bin

# Trust Alice's certificate because we trust the Bank
openssl verify -CAfile bank_cert.crt alice_cert.crt

# Extract Alice's public key from the certificate
openssl x509 -in alice_cert.crt -pubkey -noout > ./bobs/alice_public.pem

# Decrypt the Message
openssl rsautl -decrypt -inkey bob_private.key -in encrypted_message.bin -out ./bobs/decrypted_message.txt
```

In this script:
- The first set of commands (labeled "Alice's Steps") is for Alice and includes the encryption of the message and the signing of the encrypted message.
- The second set of commands (labeled "Bob's Steps") is for Bob and includes the verification of the message source and Alice's identity, as well as the decryption of the message.

Make sure to replace the placeholder filenames/paths (`plaintext_message.txt`, `bob_public.pem`, `alice_private.key`, `alice_cert.crt`, `bank_cert.crt`, `encrypted_message.sha256`, `encrypted_message.bin`, `bob_private.key`) with the actual filenames/paths relevant to your setup.
